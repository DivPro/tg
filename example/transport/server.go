// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"encoding/json"
	"io"
	"net/http"
	_ "net/http/pprof"
	"runtime"
	"time"

	"github.com/fasthttp/router"
	"github.com/savsgio/gotils"
	"github.com/sirupsen/logrus"
	"github.com/valyala/fasthttp"
	"github.com/valyala/fasthttp/fasthttpadaptor"
)

const maxRequestBodySize = 104857600

type middleware func(fasthttp.RequestHandler) fasthttp.RequestHandler

type Server struct {
	log logrus.FieldLogger

	httpAfter  []Handler
	httpBefore []Handler

	maxRequestBodySize int

	srvHTTP   *fasthttp.Server
	srvHealth *fasthttp.Server
	srvPPROF  *fasthttp.Server

	reporterCloser io.Closer

	router *router.Router

	httpJsonRPC *httpJsonRPC
	httpUser    *httpUser
}

func New(log logrus.FieldLogger, options ...Option) (srv *Server) {

	srv = &Server{
		log:                log,
		maxRequestBodySize: maxRequestBodySize,
		router:             router.New(),
	}
	srv.router.POST("/", srv.serveBatch)
	for _, option := range options {
		option(srv)
	}
	return
}

func (srv *Server) ServeHTTP(address string, wraps ...middleware) {

	srv.log.WithField("address", address).Info("enable HTTP transport")
	handler := srv.httpHandler()

	for _, wrap := range wraps {
		handler = wrap(handler)
	}
	srv.srvHTTP = &fasthttp.Server{
		Handler:            handler,
		MaxRequestBodySize: srv.maxRequestBodySize,
		ReadTimeout:        time.Second * 10,
	}
	go func() {
		err := srv.srvHTTP.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve http on "+address)
	}()
}

func (srv *Server) ServeHTTPS(address, certFile, keyFile string, wraps ...middleware) {

	srv.log.WithField("address", address).Info("enable HTTP transport")
	handler := srv.httpHandler()

	for _, wrap := range wraps {
		handler = wrap(handler)
	}
	srv.srvHTTP = &fasthttp.Server{
		Handler:            handler,
		MaxRequestBodySize: srv.maxRequestBodySize,
		ReadTimeout:        time.Second * 10,
	}
	go func() {
		err := srv.srvHTTP.ListenAndServeTLS(address, certFile, keyFile)
		ExitOnError(srv.log, err, "serve http on "+address)
	}()
}

func (srv *Server) httpHandler() fasthttp.RequestHandler {
	return func(ctx *fasthttp.RequestCtx) {

		for _, before := range srv.httpBefore {
			before(ctx)
		}
		srv.router.Handler(ctx)

		for _, after := range srv.httpAfter {
			after(ctx)
		}
	}
}

func (srv *Server) Router() *router.Router {
	return srv.router
}

func (srv *Server) WithLog(log logrus.FieldLogger) *Server {
	if srv.httpJsonRPC != nil {
		srv.httpJsonRPC = srv.JsonRPC().WithLog(log)
	}
	if srv.httpUser != nil {
		srv.httpUser = srv.User().WithLog(log)
	}
	return srv
}

func (srv *Server) WithTrace() *Server {
	if srv.httpJsonRPC != nil {
		srv.httpJsonRPC = srv.JsonRPC().WithTrace()
	}
	if srv.httpUser != nil {
		srv.httpUser = srv.User().WithTrace()
	}
	return srv
}

func (srv *Server) WithMetrics() *Server {
	if srv.httpJsonRPC != nil {
		srv.httpJsonRPC = srv.JsonRPC().WithMetrics()
	}
	if srv.httpUser != nil {
		srv.httpUser = srv.User().WithMetrics()
	}
	return srv
}

func (srv *Server) ServePPROF(address string) {

	runtime.SetBlockProfileRate(1)
	runtime.SetMutexProfileFraction(5)

	srv.srvPPROF = &fasthttp.Server{
		Handler:     fasthttpadaptor.NewFastHTTPHandler(http.DefaultServeMux),
		ReadTimeout: time.Second * 10,
	}

	go func() {
		err := srv.srvPPROF.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve PPROF on "+address)
	}()
}

func (srv *Server) ServeHealth(address string) {

	srv.srvHealth = &fasthttp.Server{
		Handler: func(ctx *fasthttp.RequestCtx) {
			ctx.SetStatusCode(fasthttp.StatusOK)
			_, _ = ctx.WriteString("ok")
		},
		ReadTimeout: time.Second * 10,
	}
	go func() {
		err := srv.srvHealth.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve health on "+address)
	}()
}

func (srv *Server) Shutdown() {

	if srv.srvHTTP != nil {
		_ = srv.srvHTTP.Shutdown()
	}

	if srv.srvHealth != nil {
		_ = srv.srvHealth.Shutdown()
	}

	if srvMetrics != nil {
		_ = srvMetrics.Shutdown()
	}

	if srv.srvPPROF != nil {
		_ = srv.srvPPROF.Shutdown()
	}
}

func sendResponse(log logrus.FieldLogger, ctx *fasthttp.RequestCtx, resp interface{}) {

	ctx.SetContentType("application/json")

	if err := json.NewEncoder(ctx).Encode(resp); err != nil {
		log.WithField("body", gotils.B2S(ctx.PostBody())).WithError(err).Error("response write error")
	}
}

func (srv Server) JsonRPC() *httpJsonRPC {
	return srv.httpJsonRPC
}

func (srv Server) User() *httpUser {
	return srv.httpUser
}
