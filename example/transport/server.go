// GENERATED BY 'T'ransport 'G'enerator. DO NOT EDIT.
package transport

import (
	"encoding/json"
	"io"
	"net/http"
	_ "net/http/pprof"
	"runtime"
	"time"

	"github.com/fasthttp/router"
	"github.com/lab259/cors"
	"github.com/savsgio/gotils"
	"github.com/sirupsen/logrus"
	"github.com/valyala/fasthttp"
	"github.com/valyala/fasthttp/fasthttpadaptor"

	"github.com/seniorGolang/tg/example/implement"
	"github.com/seniorGolang/tg/example/interfaces"
)

const maxRequestBodySize = 104857600

type Server struct {
	*httpServer

	srvHealth  *fasthttp.Server
	srvPPROF   *fasthttp.Server
	srvMetrics *fasthttp.Server

	reporterCloser io.Closer

	router      *router.Router
	httpJsonRPC *httpJsonRPC

	httpUser *httpUser
}

func New(log logrus.FieldLogger, svcJsonRPC interfaces.JsonRPC, svcUser interfaces.User) (srv *Server) {

	srv = &Server{
		httpJsonRPC: NewJsonRPC(log, svcJsonRPC),
		httpServer: &httpServer{
			log:                log,
			maxRequestBodySize: maxRequestBodySize,
		},
		httpUser: NewUser(log, svcUser),
		router:   router.New(),
	}
	srv.router.POST("/", srv.serveBatch)
	srv.router.POST("/jsonrpc", srv.httpJsonRPC.serveBatch)
	srv.router.POST("/jsonRPC/test", srv.httpJsonRPC.serveTest)

	srv.router.GET("/api/v2/user/info", srv.httpUser.serveGetUser)
	srv.router.POST("/api/v2/user/file", srv.httpUser.serveUploadFile)
	srv.router.PATCH("/api/v2/user/custom/response", srv.httpUser.serveCustomResponse)
	srv.router.DELETE("/api/v2/user/custom", implement.CustomHandler)

	return
}

func (srv Server) User() MiddlewareSetUser {
	return srv.httpUser.svc
}

func (srv Server) JsonRPC() MiddlewareSetJsonRPC {
	return srv.httpJsonRPC.svc
}

func (srv *Server) ServeHTTP(address string, options ...Option) {

	srv.applyOptions(options...)
	srv.httpUser.applyOptions(options...)
	srv.httpJsonRPC.applyOptions(options...)

	srv.log.WithField("address", address).Info("enable HTTP transport")

	srv.srvHttp = &fasthttp.Server{
		Handler:            cors.AllowAll().Handler(srv.router.Handler),
		MaxRequestBodySize: srv.maxRequestBodySize,
		ReadTimeout:        time.Second * 10,
	}

	go func() {
		err := srv.srvHttp.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve http on "+address)
	}()
}

func (srv *Server) ServeHTTPS(address, certFile, keyFile string, options ...Option) {

	srv.applyOptions(options...)
	srv.httpUser.applyOptions(options...)
	srv.httpJsonRPC.applyOptions(options...)

	srv.log.WithField("address", address).Info("enable HTTP transport")

	srv.srvHttp = &fasthttp.Server{
		Handler:            cors.AllowAll().Handler(srv.router.Handler),
		MaxRequestBodySize: srv.maxRequestBodySize,
		ReadTimeout:        time.Second * 10,
	}

	go func() {
		err := srv.srvHttp.ListenAndServeTLS(address, certFile, keyFile)
		ExitOnError(srv.log, err, "serve http on "+address)
	}()
}

func (srv *Server) Router() *router.Router {
	return srv.router
}

func (srv *Server) WithLog(log logrus.FieldLogger) *Server {
	srv.JsonRPC().WithLog(log)
	srv.User().WithLog(log)
	return srv
}

func (srv *Server) WithTrace() *Server {
	srv.JsonRPC().WithTrace()
	srv.User().WithTrace()
	return srv
}

func (srv *Server) ServePPROF(address string) {

	runtime.SetBlockProfileRate(1)
	runtime.SetMutexProfileFraction(5)

	srv.srvPPROF = &fasthttp.Server{
		Handler:     fasthttpadaptor.NewFastHTTPHandler(http.DefaultServeMux),
		ReadTimeout: time.Second * 10,
	}

	go func() {
		err := srv.srvPPROF.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve PPROF on "+address)
	}()
}

func (srv *Server) ServeHealth(address string) {

	srv.srvMetrics = &fasthttp.Server{
		Handler: func(ctx *fasthttp.RequestCtx) {
			ctx.SetStatusCode(fasthttp.StatusOK)
			_, _ = ctx.WriteString("ok")
		},
		ReadTimeout: time.Second * 10,
	}

	go func() {
		err := srv.srvMetrics.ListenAndServe(address)
		ExitOnError(srv.log, err, "serve health on "+address)
	}()
}

func (srv *Server) Shutdown() {

	if srv.srvHttp != nil {
		_ = srv.srvHttp.Shutdown()
	}

	if srv.srvHealth != nil {
		_ = srv.srvHealth.Shutdown()
	}

	if srv.srvMetrics != nil {
		_ = srv.srvMetrics.Shutdown()
	}

	if srv.srvPPROF != nil {
		_ = srv.srvPPROF.Shutdown()
	}
}

func sendResponse(log logrus.FieldLogger, ctx *fasthttp.RequestCtx, resp interface{}) {

	ctx.SetContentType("application/json")

	if err := json.NewEncoder(ctx).Encode(resp); err != nil {
		log.WithField("body", gotils.B2S(ctx.PostBody())).WithError(err).Error("response write error")
	}
}
